(window.webpackJsonp=window.webpackJsonp||[]).push([[86],{785:function(e,n,t){"use strict";t.r(n);var a=t(5),l=Object(a.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"_1-introduction"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-introduction"}},[e._v("#")]),e._v(" 1. Introduction")]),e._v(" "),t("p",[e._v("In Java 8, HashMap has been redesigned. The most different point is the usage of Red-Black-Tree, so HashMap in Java 8 is comprised of array, linked list and Red-Black-Tree."),t("br"),e._v("\nI have introduced HashMap in Java 7 that when we want to find a value, we need to find index of array firstlym the iterate a linked list. And, the runtime of iteration of linked list is O(N). To solve this problem, In Java 8, the linked list in Java 7 is replace with Red-Black-Tree when the number of elements is over 8."),t("br"),t("br"),e._v("\nThe following picture will show you the constructure:")]),e._v(" "),t("p",[t("img",{attrs:{src:"Concurrency-Java-HashMapInJDK1-8/1.png",alt:""}})]),e._v(" "),t("p",[e._v("Then I will show you the source code. In Java 7, we use Entry to present every element in HashMap, nd In Java 8 we use Node. They are almost the same that both of them are comprised of key, value, hash and next. But if the constructure is Red-Black-Tree, then we use TreeNode.")]),e._v(" "),t("h2",{attrs:{id:"_2-put"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-put"}},[e._v("#")]),e._v(" 2. Put")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("public V put(K key, V value) {\n    return putVal(hash(key), key, value, false, true);\n}\n\n// if the 3rd parameter onlyIfAbsent is true, then do the put only when the key does not exist\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n               boolean evict) {\n    Node<K,V>[] tab; Node<K,V> p; int n, i;\n    // when put at the first time, it will invoke resize() to initial length of array\n    if ((tab = table) == null || (n = tab.length) == 0)\n        n = (tab = resize()).length;\n    // find the index of array, if there are none, then initail the next Node and put it in here\n    if ((p = tab[i = (n - 1) & hash]) == null)\n        tab[i] = newNode(hash, key, value, null);\n\n    else {// if exists data in this position\n        Node<K,V> e; K k;\n        // judge whether data we want to put equals to the data in the first place\n        if (p.hash == hash &&\n            ((k = p.key) == key || (key != null && key.equals(k))))\n            e = p;\n        // if it is a node of Red-Black-Tree, the use put of Red-Black-Tree\n        else if (p instanceof TreeNode)\n            e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);\n        else {\n            for (int binCount = 0; ; ++binCount) {\n                // put into the last of linked list\n                if ((e = p.next) == null) {\n                    p.next = newNode(hash, key, value, null);\n                    // TREEIFY_THRESHOLD is 8, so, the number of elements is over 8, then turn the linked list into Red-Black-Tree\n                    if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st\n                        treeifyBin(tab, hash);\n                    break;\n                }\n                if (e.hash == hash &&\n                    ((k = e.key) == key || (key != null && key.equals(k))))\n                    break;\n                p = e;\n            }\n        }\n        if (e != null) {\n            V oldValue = e.value;\n            if (!onlyIfAbsent || oldValue == null)\n                e.value = value;\n            afterNodeAccess(e);\n            return oldValue;\n        }\n    }\n    ++modCount;\n    // If it is over threshold, then do rehash\n    if (++size > threshold)\n        resize();\n    afterNodeInsertion(evict);\n    return null;\n}\n")])])]),t("p",[e._v("The differenct between Java 7 and 8 is that In java 7 do rehash the put and In Java 8 do put then rehash.")]),e._v(" "),t("h2",{attrs:{id:"_3-resize"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-resize"}},[e._v("#")]),e._v(" 3. Resize")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("final Node<K,V>[] resize() {\n    Node<K,V>[] oldTab = table;\n    int oldCap = (oldTab == null) ? 0 : oldTab.length;\n    int oldThr = threshold;\n    int newCap, newThr = 0;\n    if (oldCap > 0) { \n        if (oldCap >= MAXIMUM_CAPACITY) {\n            threshold = Integer.MAX_VALUE;\n            return oldTab;\n        }\n        // double the array\n        else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&\n                 oldCap >= DEFAULT_INITIAL_CAPACITY)\n            // double the threshold\n            newThr = oldThr << 1; // double threshold\n    }\n    else if (oldThr > 0) // \n        newCap = oldThr;\n    else {\n        newCap = DEFAULT_INITIAL_CAPACITY;\n        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n    }\n\n    if (newThr == 0) {\n        float ft = (float)newCap * loadFactor;\n        newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?\n                  (int)ft : Integer.MAX_VALUE);\n    }\n    threshold = newThr;\n\n    // use new length to init new array\n    Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];\n    table = newTab; // If it just inits a array then finished and return the newTab\n\n    if (oldTab != null) {\n        // iterate the old array and move data\n        for (int j = 0; j < oldCap; ++j) {\n            Node<K,V> e;\n            if ((e = oldTab[j]) != null) {\n                oldTab[j] = null;\n                // move single data\n                if (e.next == null)\n                    newTab[e.hash & (newCap - 1)] = e;\n                // move data in Red-Black-Tree\n                else if (e instanceof TreeNode)\n                    ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);\n                else { \n                    Node<K,V> loHead = null, loTail = null;\n                    Node<K,V> hiHead = null, hiTail = null;\n                    Node<K,V> next;\n                    do {\n                        next = e.next;\n                        if ((e.hash & oldCap) == 0) {\n                            if (loTail == null)\n                                loHead = e;\n                            else\n                                loTail.next = e;\n                            loTail = e;\n                        }\n                        else {\n                            if (hiTail == null)\n                                hiHead = e;\n                            else\n                                hiTail.next = e;\n                            hiTail = e;\n                        }\n                    } while ((e = next) != null);\n                    if (loTail != null) {\n                        loTail.next = null;\n                        // the first linked list\n                        newTab[j] = loHead;\n                    }\n                    if (hiTail != null) {\n                        hiTail.next = null;\n                        newTab[j + oldCap] = hiHead;\n                    }\n                }\n            }\n        }\n    }\n    return newTab;\n}\n")])])]),t("h2",{attrs:{id:"_4-get"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-get"}},[e._v("#")]),e._v(" 4. Get")]),e._v(" "),t("p",[e._v("Get is easy.")]),e._v(" "),t("ol",[t("li",[e._v("compute hash value of key, find index in array accoding hash value.")]),e._v(" "),t("li",[e._v("judge whether the data we want is in the array, if not do 3rd step.")]),e._v(" "),t("li",[e._v("judge whether type of the data is TreeNode, do put of Red-Black-Tree if true, do 4th step if not.")]),e._v(" "),t("li",[e._v("iterate linkedl list until find the key.")])])])}),[],!1,null,null,null);n.default=l.exports}}]);
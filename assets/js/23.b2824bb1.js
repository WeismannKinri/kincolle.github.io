(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{563:function(e,r,t){e.exports=t.p+"assets/img/JMM.c883ca4c.jpg"},564:function(e,r,t){e.exports=t.p+"assets/img/communication.20cb5d95.jpg"},565:function(e,r,t){e.exports=t.p+"assets/img/reorder.e15bdb5b.jpg"},566:function(e,r,t){e.exports=t.p+"assets/img/reorderinstance.f8bb45b4.jpg"},702:function(e,r,t){"use strict";t.r(r);var a=t(0),o=Object(a.a)({},(function(){var e=this,r=e.$createElement,a=e._self._c||r;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"jmm"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#jmm"}},[e._v("#")]),e._v(" JMM")]),e._v(" "),a("h2",{attrs:{id:"_1-abstraction-of-java-memory-model"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-abstraction-of-java-memory-model"}},[e._v("#")]),e._v(" 1 Abstraction of Java Memory Model")]),e._v(" "),a("p",[e._v("In java, all the instance area, static area and array are stored in stack memory, and the stack memory are shared among threads. Local variables, formal method parameters and exception handler parameters will no be shared among threads, so there will be no visibility problem and will not be affected by JMM.\nCommunication of threads is controlled by JMM, JMM can make a decision that which thread can write data into shared variables that are visible to others.It can be said that JMM define the relationship between thread and main memory: shared variables of threads are stored in main memory, every thread can have a local memory, and in local memory the replication are stored for write/read by this thread. JMM is an abstract conception and it does not really exist. It contains buffer, register and other hardwares. The JMM is showed as the following picture.")]),e._v(" "),a("p",[a("img",{attrs:{src:t(563),alt:""}})]),e._v(" "),a("p",[e._v("according to the picture, if thread A and thread B want to communicate with each other, 2 steps must be done:"),a("br"),e._v("\n1.first, thread A make the shared variables which are updated and stored in local memory of A into main memory."),a("br"),e._v("\n2.second, thread B get the shared data which has updated by thread a.\n"),a("br")]),e._v(" "),a("p",[e._v("The following picture will show you the detail steps:"),a("br")]),e._v(" "),a("p",[a("img",{attrs:{src:t(564),alt:""}})]),e._v(" "),a("p",[e._v("As the picture shows, local memory A and B have replication of the share variable x.Persuming that at the first time in all three memoris the value of x is 0. Thread A update x into 1 and the value will be stored at local variable of A. when A and B want communicate, A when update main memory by using local variable of A, then in main memory the x is 1. Thread B go into main memory to get value of x which is 1 and update local variable of B, at this time the value of local variable of B is 1."),a("br"),e._v("\nWe can see that A send message to B by using main memory. JMM control communication of main memory and every thread. to make sure the visibility of memory."),a("br")]),e._v(" "),a("h2",{attrs:{id:"_2-reordering"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-reordering"}},[e._v("#")]),e._v(" 2 Reordering")]),e._v(" "),a("p",[e._v("For higher performance of executing program, compiler and CPU always reorder the code. There are three types of reordering:"),a("br"),e._v("\n1.compiler optimization reorder: Without change meaning of code, or instruction of single thread, compiler will changer order of execution."),a("br"),e._v("\n2.instruction paralell reorder: Modern CPU use Instruction-Level Parallelism to execute instructions. If there is no dependency, CPU can change order of instructions of execution."),a("br"),e._v("\n3.memory system reorder: Due to using of buffer of CPU, this make loading and storing execution seems execution at a random order."),a("br"),e._v("\nFrom java source to instruction of final execution, tree ordering has been done: reorder")]),e._v(" "),a("p",[a("img",{attrs:{src:t(565),alt:""}})]),e._v(" "),a("p",[e._v("In the picture, No.1 is compiler optimization reorder, No.2 and No.3 is CPU reordering. These reordering may have problems when concurrency happen in memory. JMM is memory model with language level, at different platform, by forbiding some reordering it can make sure of visibility of memory.")]),e._v(" "),a("h2",{attrs:{id:"_4-cpu-reordering-and-memory-barrier"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-cpu-reordering-and-memory-barrier"}},[e._v("#")]),e._v(" 4 CPU Reordering and Memory Barrier")]),e._v(" "),a("p",[e._v("Modern CPU use buffer to temporarily store data which will be store in main memory. Every buffer is just visible to its CPUã€‚ That will affect the order of instructions to the memory:")]),e._v(" "),a("table",[a("thead",[a("tr",[a("th",[e._v("Processor A")]),e._v(" "),a("th",[e._v("Processor B")])])]),e._v(" "),a("tbody",[a("tr",[a("td",[e._v("a = 1;//A1"),a("br"),e._v("x = b;//A2")]),e._v(" "),a("td",[e._v("b = 2;//A1"),a("br"),e._v("y = a;//A2")])]),e._v(" "),a("tr",[a("td",[e._v("initial status: a=b=0"),a("br"),e._v(" executed result: x=y=0")]),e._v(" "),a("td",[e._v(":")])])])]),e._v(" "),a("p",[e._v("Persuming CPU A and CPU B access memory in the code order, but the final result is x=y=0. The detail reason is showed in the following picture.")]),e._v(" "),a("p",[a("img",{attrs:{src:t(566),alt:""}})]),e._v(" "),a("p",[e._v("Here both CPU A and CPU B can write shared variable into their buffer ( A1 And A2 ), then from the buffer to ( A2 and B2) , finally copy the data which is already writen in buffer to main memory ( A3 and B3). When execute in this order, the result is x=y=0."),a("br"),e._v("\nFor main memory, only when CPU A finish executing A3 the A1 is real finished. So the code is A1 -> A2, but the real executing order is A2 -> A1."),a("br"),e._v("\nThe key point is that buffer is only visible to its CPU, this may lead some problems. Because modern CPU using buffer, reordering offen happens."),a("br"),e._v("\nTo make sure the visibility, java compiler will insert some memory barriers into instructions to forbid some reordering. There are four types of memory barriers showed at the following table:")]),e._v(" "),a("table",[a("thead",[a("tr",[a("th",[e._v("type")]),e._v(" "),a("th",[e._v("content")]),e._v(" "),a("th",[e._v("description")])])]),e._v(" "),a("tbody",[a("tr",[a("td",[e._v("LoadLoad Barriers")]),e._v(" "),a("td",[e._v("Load1; LoadLoad; Load2")]),e._v(" "),a("td",[e._v("Make sure Load 1 must be before Load 2 and other following loadings")])]),e._v(" "),a("tr",[a("td",[e._v("StoreStore Barriers")]),e._v(" "),a("td",[e._v("Store1; StoreStore; Store2")]),e._v(" "),a("td",[e._v("Make sure Store 1 must be visible to other CPU and before Store 2 and other following Storing")])]),e._v(" "),a("tr",[a("td",[e._v("LoadStore Barriers")]),e._v(" "),a("td",[e._v("Load1; LoadStore; Store2")]),e._v(" "),a("td",[e._v("Make sure Load 1 must be bofore Store 2 and other following instructions")])]),e._v(" "),a("tr",[a("td",[e._v("StoreLoad Barriers")]),e._v(" "),a("td",[e._v("Store1; StoreLoad; Load2")]),e._v(" "),a("td",[e._v("Make sure all the memory instructions finished before instructions after Barriers")])])])]),e._v(" "),a("h2",{attrs:{id:"_5-happens-before-rule"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-happens-before-rule"}},[e._v("#")]),e._v(" 5 Happens-Before Rule")]),e._v(" "),a("p",[e._v("I have already explained what is reordering, although java will do reordering, there are some rules needs to follow. The following will show you the rules:")]),e._v(" "),a("ul",[a("li",[e._v("in one thread the instructions must be serial")]),e._v(" "),a("li",[e._v("volatile variable must be writen before read to make sure the visibility")]),e._v(" "),a("li",[e._v("unlock must before lock")]),e._v(" "),a("li",[e._v("A->B, B->C, then A->C")]),e._v(" "),a("li",[e._v("start() is the first execution for all threads")]),e._v(" "),a("li",[e._v("execution of all threads before Thread.join()")]),e._v(" "),a("li",[e._v("interrupt() of one thread must before the code of the interrupted thread")]),e._v(" "),a("li",[e._v("construction of one object must before finalize()")])]),e._v(" "),a("p",[e._v("For example, reordering must not change the meaning of serial meaning of codes, like")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("a=1;\nb=a+1;\n")])])]),a("p",[e._v("Because the second code is depending on first code, so if change the order of the two codes the result of execution will be changed.")]),e._v(" "),a("h2",{attrs:{id:"_6-data-dependency"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-data-dependency"}},[e._v("#")]),e._v(" 6 Data dependency")]),e._v(" "),a("p",[e._v("If there are 2 execution and more one is writing, then the 2 execution has dependency. There are 3 types of denpendecny:")]),e._v(" "),a("table",[a("thead",[a("tr",[a("th",[e._v("Name")]),e._v(" "),a("th",[e._v("example")]),e._v(" "),a("th",[e._v("description")])])]),e._v(" "),a("tbody",[a("tr",[a("td",[e._v("write then read")]),e._v(" "),a("td",[e._v("a=1; b=a;")]),e._v(" "),a("td",[e._v("write one variable then read it")])]),e._v(" "),a("tr",[a("td",[e._v("write then write")]),e._v(" "),a("td",[e._v("a=1; a=2;")]),e._v(" "),a("td",[e._v("write one variable then write it again")])]),e._v(" "),a("tr",[a("td",[e._v("read then write")]),e._v(" "),a("td",[e._v("a=b; b=1;")]),e._v(" "),a("td",[e._v("read one variable then write it")])])])]),e._v(" "),a("p",[e._v("When compiler do reordering, there rules must be followed.")])])}),[],!1,null,null,null);r.default=o.exports}}]);
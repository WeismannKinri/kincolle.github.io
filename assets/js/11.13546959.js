(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{607:function(e,t,a){e.exports=a.p+"assets/img/1.8d039470.png"},608:function(e,t,a){e.exports=a.p+"assets/img/2.c0912b63.png"},609:function(e,t,a){e.exports=a.p+"assets/img/3.3a4d6396.png"},610:function(e,t,a){e.exports=a.p+"assets/img/4.4db2bd8a.png"},611:function(e,t,a){e.exports=a.p+"assets/img/5.da8b003a.png"},612:function(e,t,a){e.exports=a.p+"assets/img/6.c5ecbc10.png"},613:function(e,t,a){e.exports=a.p+"assets/img/7.80f5dcd6.png"},614:function(e,t,a){e.exports=a.p+"assets/img/8.a1407305.png"},725:function(e,t,a){"use strict";a.r(t);var n=a(0),s=Object(n.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h2",{attrs:{id:"introduction-of-consistent-hashing-algorithm"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#introduction-of-consistent-hashing-algorithm"}},[e._v("#")]),e._v(" Introduction of Consistent Hashing Algorithm")]),e._v(" "),n("p",[e._v("The Consistent hashing can guarantee that when a node is removed, only the keys stored in it will be rehashed; when a new node is added, only a fairly few keys will be rehashed.")]),e._v(" "),n("h5",{attrs:{id:"hash-space"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#hash-space"}},[e._v("#")]),e._v(" Hash space")]),e._v(" "),n("p",[e._v("Commonly, a hash function will map a value into a 32-bit key, 0~2^32-1. Now imagine mapping the range into a circle, then the key will be wrapped, and 0 will be followed by 2^32-1.")]),e._v(" "),n("p",[n("img",{attrs:{src:a(607),alt:""}})]),e._v(" "),n("h5",{attrs:{id:"map-key-into-hash-space"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#map-key-into-hash-space"}},[e._v("#")]),e._v(" Map key into hash space")]),e._v(" "),n("p",[e._v("Now consider four key1: key1~key4. We use a hash function to get their key values and map them into the circle, as illustrated in the following picture.")]),e._v(" "),n("p",[n("img",{attrs:{src:a(608),alt:""}})]),e._v(" "),n("h5",{attrs:{id:"map-the-node-into-hash-space"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#map-the-node-into-hash-space"}},[e._v("#")]),e._v(" Map the node into hash space")]),e._v(" "),n("p",[e._v("The basic idea of consistent hashing is to map the node and keys into the same hash space using the same hash function. Now consider we have 4 nodes, node1, node2, node3 and node4, and then the mapping result will look like in the following picture.")]),e._v(" "),n("p",[n("img",{attrs:{src:a(609),alt:""}})]),e._v(" "),n("h5",{attrs:{id:"map-keys-into-node"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#map-keys-into-node"}},[e._v("#")]),e._v(" Map keys into node")]),e._v(" "),n("p",[e._v("Now all the nodes and keys are hashed into the same space, so we can determine how to map keys into nodes. Take key for example, just start from where key is and head clockwise on the ring until you find a server. If that server is down, you go to the next one, and so forth. See the picture above. According to the method, key1 will be stored into node1; key2 and key3 will be stored into node2, and key4 will be stored into node3.")]),e._v(" "),n("p",[n("img",{attrs:{src:a(610),alt:""}})]),e._v(" "),n("h5",{attrs:{id:"add-node"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#add-node"}},[e._v("#")]),e._v(" Add node")]),e._v(" "),n("p",[e._v("A new node4 is added")]),e._v(" "),n("p",[n("img",{attrs:{src:a(611),alt:""}})]),e._v(" "),n("p",[e._v("Since node4 is hashed between node1 and node2 in the ring, then only the keys that are between node1 and node2 will be rehashed; in the example, key2 will be stored in node4, illustrated in the following picture.")]),e._v(" "),n("p",[n("img",{attrs:{src:a(612),alt:""}})]),e._v(" "),n("h5",{attrs:{id:"remove-node"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#remove-node"}},[e._v("#")]),e._v(" Remove node")]),e._v(" "),n("p",[e._v("node3 is removed")]),e._v(" "),n("p",[n("img",{attrs:{src:a(613),alt:""}})]),e._v(" "),n("p",[e._v("Since node3 is removed, then only the keys that in node3 will be rehashed and moved to node1; in the example, see key4 illustrated in the following picture.")]),e._v(" "),n("p",[n("img",{attrs:{src:a(614),alt:""}})])])}),[],!1,null,null,null);t.default=s.exports}}]);
(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{645:function(t,e,n){t.exports=n.p+"assets/img/RBT1.17102e26.png"},646:function(t,e,n){t.exports=n.p+"assets/img/RBT2.0da993d3.png"},647:function(t,e,n){t.exports=n.p+"assets/img/RBT3.548fe23e.png"},648:function(t,e,n){t.exports=n.p+"assets/img/RBT4.a94fe143.png"},649:function(t,e,n){t.exports=n.p+"assets/img/RBT5.24274ac1.png"},650:function(t,e,n){t.exports=n.p+"assets/img/RBT6.979ad73e.png"},651:function(t,e,n){t.exports=n.p+"assets/img/RBT7.2892ab36.png"},789:function(t,e,n){"use strict";n.r(e);var r=n(5),a=Object(r.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"red-black-tree-and-treemap-and-treeset"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#red-black-tree-and-treemap-and-treeset"}},[t._v("#")]),t._v(" Red Black Tree and TreeMap and TreeSet")]),t._v(" "),r("h2",{attrs:{id:"_1-introduction-of-red-black-tree"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-introduction-of-red-black-tree"}},[t._v("#")]),t._v(" 1 Introduction of Red Black Tree")]),t._v(" "),r("p",[t._v("Java TreeMap implements SortedMap interface, that is to say it can sort elements according to key. You can use natural ordering or override a Comparator."),r("br"),t._v("\nTreeMap is using Red-Black tree, which means the runtime of containsKey(), get(), put() and remove() are log(n)."),r("br"),t._v(" "),r("img",{attrs:{src:n(645),alt:""}}),t._v("\nBy the way, TreeMap is not thread safe."),r("br"),r("br"),t._v("\nThe Red-Black tree is near to the Binary Search Tree, and it will make sure in any subtree, high of any two nodes will less than two times. In detail, there are some conditions should be satisfied:")]),t._v(" "),r("ul",[r("li",[t._v("There are only two kinds of node, red and black.")]),t._v(" "),r("li",[t._v("Root node must be black node.")]),t._v(" "),r("li",[t._v("Red node can not be continued.(Which means neither father node or child node of a red node should not be a red node)")]),t._v(" "),r("li",[t._v("From every node to ant of its null node, the number of black node is the same.")])]),t._v(" "),r("p",[t._v("When the structure of the tree has been changed(like inserting of deleting), the 3rd or 4th contition will be destroyed, so it need be reconstructed to satisfy all the conditions.")]),t._v(" "),r("h2",{attrs:{id:"_2-some-knowledge-of-red-black-tree"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-some-knowledge-of-red-black-tree"}},[t._v("#")]),t._v(" 2 Some Knowledge of Red Black Tree")]),t._v(" "),r("h5",{attrs:{id:"rotate-left"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#rotate-left"}},[t._v("#")]),t._v(" Rotate Left")]),t._v(" "),r("p",[t._v("Rotating left means let right tree of x be father of x. When finish, the conditions of Red Black Tree are still satisfied.\n"),r("img",{attrs:{src:n(646),alt:""}}),t._v("\nHere is the source code of rotating left of TreeMap:")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[t._v("//Rotate Left\nprivate void rotateLeft(Entry<K,V> p) {\n    if (p != null) {\n        Entry<K,V> r = p.right;\n        p.right = r.left;\n        if (r.left != null)\n            r.left.parent = p;\n        r.parent = p.parent;\n        if (p.parent == null)\n            root = r;\n        else if (p.parent.left == p)\n            p.parent.left = r;\n        else\n            p.parent.right = r;\n        r.left = p;\n        p.parent = r;\n    }\n}\n")])])]),r("h5",{attrs:{id:"rotate-right"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#rotate-right"}},[t._v("#")]),t._v(" Rotate Right")]),t._v(" "),r("p",[t._v("Rotating right means let left tree of x be father of x. When finish, the conditions of Red Black Tree are still satisfied.\n"),r("img",{attrs:{src:n(647),alt:""}}),t._v("\nHere is the source code of rotating right of TreeMap:")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[t._v("//Rotate Right\nprivate void rotateRight(Entry<K,V> p) {\n    if (p != null) {\n        Entry<K,V> l = p.left;\n        p.left = l.right;\n        if (l.right != null) l.right.parent = p;\n        l.parent = p.parent;\n        if (p.parent == null)\n            root = l;\n        else if (p.parent.right == p)\n            p.parent.right = l;\n        else p.parent.left = l;\n        l.right = p;\n        p.parent = l;\n    }\n}\n")])])]),r("h2",{attrs:{id:"functions-of-red-black-tree"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#functions-of-red-black-tree"}},[t._v("#")]),t._v(" Functions of Red Black Tree")]),t._v(" "),r("h5",{attrs:{id:"get"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#get"}},[t._v("#")]),t._v(" get()")]),t._v(" "),r("p",[t._v('get(Object key) function gets value according to key. This function invokes getEntry(Object key) to get the right entry, and then return "entry.value". getEntry() is the core of the algorithm. In the algorithm, search elements accoring to order of key, until we find one entry that satisfies "k.compareTo(p.key) == 0".'),r("br"),t._v(" "),r("img",{attrs:{src:n(648),alt:""}}),t._v("\nThe source code is")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[t._v("//getEntry() function\nfinal Entry<K,V> getEntry(Object key) {\n    ......\n    if (key == null)//do not allow null key\n        throw new NullPointerException();\n    Comparable<? super K> k = (Comparable<? super K>) key;//order elements\n    Entry<K,V> p = root;\n    while (p != null) {\n        int cmp = k.compareTo(p.key);\n        if (cmp < 0)//go left\n            p = p.left;\n        else if (cmp > 0)//go right\n            p = p.right;\n        else\n            return p;\n    }\n    return null;\n}\n")])])]),r("h5",{attrs:{id:"put"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#put"}},[t._v("#")]),t._v(" put()")]),t._v(" "),r("p",[t._v("put(K key, V value) function will put the key-value into a TreeMap. This function will do search for once, if the map has contained the key then replace the value, if not then insert it. Since the inserting may break the structure, so the reconstruction may start."),r("br"),t._v("\nHere is the source code:")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[t._v("public V put(K key, V value) {\n    ......\n    int cmp;\n    Entry<K,V> parent;\n    if (key == null)\n        throw new NullPointerException();\n    Comparable<? super K> k = (Comparable<? super K>) key;//order elements\n    do {\n        parent = t;\n        cmp = k.compareTo(t.key);\n        if (cmp < 0) t = t.left;//go left\n        else if (cmp > 0) t = t.right;//go right\n        else return t.setValue(value);\n    } while (t != null);\n    Entry<K,V> e = new Entry<>(key, value, parent);//create a new entry and insert it\n    if (cmp < 0) parent.left = e;\n    else parent.right = e;\n    fixAfterInsertion(e);//do rotate\n    size++;\n    return null;\n}\n")])])]),r("p",[t._v('There codes are used to put data and it\'s easy to understand: First, find the right location to put data. The hard point is "fixAfterInsertion()", as said before that the reconstruction may start.\n'),r("img",{attrs:{src:n(649),alt:""}})]),t._v(" "),r("p",[t._v("fixAfterInsertion() is showed in the following.")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[t._v("//fixAfterInsertion()\nprivate void fixAfterInsertion(Entry<K,V> x) {\n    x.color = RED;\n    while (x != null && x != root && x.parent.color == RED) {\n        if (parentOf(x) == leftOf(parentOf(parentOf(x)))) {\n            Entry<K,V> y = rightOf(parentOf(parentOf(x)));\n            if (colorOf(y) == RED) {//ify is null, treat it as black\n                setColor(parentOf(x), BLACK);              // situation1\n                setColor(y, BLACK);                        // situation1\n                setColor(parentOf(parentOf(x)), RED);      // situation1\n                x = parentOf(parentOf(x));                 // situation1\n            } else {\n                if (x == rightOf(parentOf(x))) {\n                    x = parentOf(x);                       // situation2\n                    rotateLeft(x);                         // situation2\n                }\n                setColor(parentOf(x), BLACK);              // situation3\n                setColor(parentOf(parentOf(x)), RED);      // situation3\n                rotateRight(parentOf(parentOf(x)));        // situation3\n            }\n        } else {\n            Entry<K,V> y = leftOf(parentOf(parentOf(x)));\n            if (colorOf(y) == RED) {\n                setColor(parentOf(x), BLACK);              // situation4\n                setColor(y, BLACK);                        // situation4\n                setColor(parentOf(parentOf(x)), RED);      // situation4\n                x = parentOf(parentOf(x));                 // situation4\n            } else {\n                if (x == leftOf(parentOf(x))) {\n                    x = parentOf(x);                       // situation5\n                    rotateRight(x);                        // situation5\n                }\n                setColor(parentOf(x), BLACK);              // situation6\n                setColor(parentOf(parentOf(x)), RED);      // situation6\n                rotateLeft(parentOf(parentOf(x)));         // situation6\n            }\n        }\n    }\n    root.color = BLACK;\n}\n")])])]),r("h5",{attrs:{id:"successor-node"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#successor-node"}},[t._v("#")]),t._v(" successor node")]),t._v(" "),r("p",[t._v("For a binary search tree, get a node t, you can get a successor node by using:")]),t._v(" "),r("ul",[r("li",[t._v("right subtree of t is not null, the successor node of t is the smallest one in the right subtree.")]),t._v(" "),r("li",[t._v("right subtree of t is null, then successor node of t is the first one which go left among the ancient nodes.")])]),t._v(" "),r("p",[r("img",{attrs:{src:n(650),alt:""}})]),t._v(" "),r("p",[t._v("These will be used in the removing cuntion. Here is the source code:")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[t._v("// successor() in TreeMap\nstatic <K,V> TreeMap.Entry<K,V> successor(Entry<K,V> t) {\n    if (t == null)\n        return null;\n    else if (t.right != null) {// 1. if right tree of t is not null, then it is the smallest element of this right tree\n        Entry<K,V> p = t.right;\n        while (p.left != null)\n            p = p.left;\n        return p;\n    } else {// 2. if right child of t is null, then it is first ancient who go left\n        Entry<K,V> p = t.parent;\n        Entry<K,V> ch = t;\n        while (p != null && ch == p.right) {\n            ch = p;\n            p = p.parent;\n        }\n        return p;\n    }\n}\n")])])]),r("h5",{attrs:{id:"remove"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#remove"}},[t._v("#")]),t._v(" remove()")]),t._v(" "),r("p",[t._v('Function of remove(Object key) is deleting entry of one key. This function will gey entry by using "getEntry(Object key)", and the invoke "deleteEntry(Entry<K,V> entry)" to delete one entry. Since this operation may break structure of Red Black Tree, so rotation may happen.'),r("br"),t._v('\nI have described "getEntry()", now the point is "deleteEntry()". There are two situations:')]),t._v(" "),r("ul",[r("li",[t._v("delete node p and both its left tree and right tree are null or only one not null tree.")]),t._v(" "),r("li",[t._v("delete node p and both its left tree and right tree are not null trees.")])]),t._v(" "),r("p",[t._v("In situation 1, it's easy, just delete p and use not null tree if exists to replace it. In situation 2, you can use successor s of p to replace p then use rule of situation 1 to delete s.")]),r("hr"),t._v("\nHere is the source code:"),r("p"),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[t._v("\t// deleteEntry()\n\tprivate void deleteEntry(Entry<K,V> p) {\n\t    modCount++;\n\t    size--;\n\t    if (p.left != null && p.right != null) {// 2. both left tree and right tree of p are not null treesã€‚\n\t        Entry<K,V> s = successor(p);// successor\n\t        p.key = s.key;\n\t        p.value = s.value;\n\t        p = s;\n\t    }\n\t    Entry<K,V> replacement = (p.left != null ? p.left : p.right);\n\t    if (replacement != null) {// 1. only one subtree is not null tree\n\t        replacement.parent = p.parent;\n\t        if (p.parent == null)\n\t            root = replacement;\n\t        else if (p == p.parent.left)\n\t            p.parent.left  = replacement;\n\t        else\n\t            p.parent.right = replacement;\n\t        p.left = p.right = p.parent = null;\n\t        if (p.color == BLACK)\n\t            fixAfterDeletion(replacement);// rotation\n\t    } else if (p.parent == null) {\n\t        root = null;\n\t    } else { // 1. both left tree and right tree of p are null\n\t        if (p.color == BLACK)\n\t            fixAfterDeletion(p);// rotation\n\t        if (p.parent != null) {\n\t            if (p == p.parent.left)\n\t                p.parent.left = null;\n\t            else if (p == p.parent.right)\n\t                p.parent.right = null;\n\t            p.parent = null;\n\t        }\n\t    }\n\t}\n")])])]),r("p",[t._v("In the codes, it's not difficult to understand. Here I will describe about fixAfterDeletion().\n"),r("img",{attrs:{src:n(651),alt:""}})]),t._v(" "),r("p",[t._v("In the picture above,:Situation1 turn into situation 2 firstly, or turn into situation 3 or 4. Of course, this picture does not means it must start from situation 1. From the source code we can find that: (1) if it is from 1 to 2, then situation 2 must quit the circle because x is red (2) when come into 3 or 4, it must quit the circle."),r("br"),t._v("\nHere is the source code:")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[t._v("private void fixAfterDeletion(Entry<K,V> x) {\n    while (x != root && colorOf(x) == BLACK) {\n        if (x == leftOf(parentOf(x))) {\n            Entry<K,V> sib = rightOf(parentOf(x));\n            if (colorOf(sib) == RED) {\n                setColor(sib, BLACK);                   // situation1\n                setColor(parentOf(x), RED);             // situation1\n                rotateLeft(parentOf(x));                // situation1\n                sib = rightOf(parentOf(x));             // situation1\n            }\n            if (colorOf(leftOf(sib))  == BLACK &&\n                colorOf(rightOf(sib)) == BLACK) {\n                setColor(sib, RED);                     // situation2\n                x = parentOf(x);                        // situation2\n            } else {\n                if (colorOf(rightOf(sib)) == BLACK) {\n                    setColor(leftOf(sib), BLACK);       // situation3\n                    setColor(sib, RED);                 // situation3\n                    rotateRight(sib);                   // situation3\n                    sib = rightOf(parentOf(x));         // situation3\n                }\n                setColor(sib, colorOf(parentOf(x)));    // situation4\n                setColor(parentOf(x), BLACK);           // situation4\n                setColor(rightOf(sib), BLACK);          // situation4\n                rotateLeft(parentOf(x));                // situation4\n                x = root;                               // situation4\n            }\n        } else { \n            Entry<K,V> sib = leftOf(parentOf(x));\n            if (colorOf(sib) == RED) {\n                setColor(sib, BLACK);                   // situation5\n                setColor(parentOf(x), RED);             // situation5\n                rotateRight(parentOf(x));               // situation5\n                sib = leftOf(parentOf(x));              // situation5\n            }\n            if (colorOf(rightOf(sib)) == BLACK &&\n                colorOf(leftOf(sib)) == BLACK) {\n                setColor(sib, RED);                     // situation6\n                x = parentOf(x);                        // situation6\n            } else {\n                if (colorOf(leftOf(sib)) == BLACK) {\n                    setColor(rightOf(sib), BLACK);      // situation7\n                    setColor(sib, RED);                 // situation7\n                    rotateLeft(sib);                    // situation7\n                    sib = leftOf(parentOf(x));          // situation7\n                }\n                setColor(sib, colorOf(parentOf(x)));    // situation8\n                setColor(parentOf(x), BLACK);           // situation8\n                setColor(leftOf(sib), BLACK);           // situation8\n                rotateRight(parentOf(x));               // situation8\n                x = root;                               // situation8\n            }\n        }\n    }\n    setColor(x, BLACK);\n}\n")])])]),r("h2",{attrs:{id:"treeset"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#treeset"}},[t._v("#")]),t._v(" TreeSet")]),t._v(" "),r("p",[t._v("TreeSet is based on TreeMap, so if you understand TreeMap, you already understand TreeSet:")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[t._v("public class TreeSet<E> extends AbstractSet<E>\n    implements NavigableSet<E>, Cloneable, java.io.Serializable\n{\n    ......\n    private transient NavigableMap<E,Object> m;\n    // Dummy value to associate with an Object in the backing Map\n    private static final Object PRESENT = new Object();\n    public TreeSet() {\n        this.m = new TreeMap<E,Object>();// There is a TreeMap in TreeSet\n    }\n    ......\n    public boolean add(E e) {\n        return m.put(e, PRESENT)==null;\n    }\n    ......\n}")])])])])}),[],!1,null,null,null);e.default=a.exports}}]);
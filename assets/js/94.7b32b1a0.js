(window.webpackJsonp=window.webpackJsonp||[]).push([[94],{711:function(e,a,t){"use strict";t.r(a);var r=t(0),n=Object(r.a)({},(function(){var e=this,a=e.$createElement,t=e._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"_1-introduction"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-introduction"}},[e._v("#")]),e._v(" 1 Introduction")]),e._v(" "),t("p",[e._v("The ThreadLocal is not a thread but a variable only can be used by current thread. So, it is a thread level variable."),t("br"),e._v("\nEvery thread can hold more than one ThreadLocal instances, hash them then store them into ThreadLocalMap. The key is ThreadLocal instances and value is a replica of the current thread.\n"),t("img",{attrs:{src:"Concurrency-Java-ThreadLocal/1.png",alt:""}}),e._v("\nFrom the picture we can see that ThreadLocal does not store value but key."),t("br"),e._v("\nHere is an example:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('public class ThreadLocalDemo {\n    public static void main(String []args){\n        for(int i=0;i<5;i++){\n            final Thread t = new Thread(){\n                @Override\n                public void run(){\n                    System.out.println("The current thread:"+Thread.currentThread().getName()+",ID:"+ThreadId.get());\n                }\n            };\n            t.start();\n        }\n    }\n    static   class ThreadId{\n        //an increasing order, use AtomicInger for thread safe\n        private static final AtomicInteger nextId = new AtomicInteger(0);\n        //ThreadLocal variable, every thread with a unique ID\n        private static final ThreadLocal<Integer> threadId =\n                new ThreadLocal<Integer>() {\n                    @Override\n                    protected Integer initialValue() {\n                        return nextId.getAndIncrement();// nextId++\n                    }\n                };\n\n       // return unique id of the current thread, if get first then initialValue\n        public static int get() {\n            return threadId.get();\n        }\n    }\n} \n')])])]),t("p",[e._v("The result is:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("The current thread:Thread-4,ID:1\nThe current thread:Thread-0,ID:0\nThe current thread:Thread-2,ID:3\nThe current thread:Thread-1,ID:4\nThe current thread:Thread-3,ID:2 \n")])])]),t("h2",{attrs:{id:"_2-source-code-learning"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-source-code-learning"}},[e._v("#")]),e._v(" 2 Source Code Learning")]),e._v(" "),t("h5",{attrs:{id:"set"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#set"}},[e._v("#")]),e._v(" Set")]),e._v(" "),t("p",[e._v("Here is the source code:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("public void set(T value) {\n\tThread t = Thread.currentThread();//1.Get current thread instance first\n\t    ThreadLocalMap map = getMap(t);//2.Get ThreadLocalMap of the current thread\n\t    if (map != null)\n\t        map.set(this, value);//If map is not null then set\n    \telse\n        \tcreateMap(t, value);//If map is null then create ThreadLocalMap\n}\n")])])]),t("p",[e._v("We can see the ThreadLocal is just an entrance, the real value is binded with threads.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("ThreadLocalMap getMap(Thread t) {\n    return t.threadLocals;// Thread has the pointer to ThreadLocalMap\n}\n")])])]),t("p",[e._v("The following is a difinition in Thread clas, and every thread haas a ThreadLocalMap instance.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("ThreadLocal.ThreadLocalMap threadLocals = null;\n")])])]),t("p",[e._v("Here we can see the design of ThreadLocal:")]),e._v(" "),t("ol",[t("li",[e._v("The ThreadLocal is just a entrance of variables")]),e._v(" "),t("li",[e._v("Every thread instance has a ThreadLocalMap instance, this ThreadLocalMap has the point to the real value")]),e._v(" "),t("li",[e._v("The ThreadLoca is key of ThreadLocalMap and value of ThreadLocalMap is the real data we want to store. When invoking get we can get the value we want at the current thread.")])]),e._v(" "),t("p",[e._v("By the way, this design has 2 benificial points that:")]),e._v(" "),t("ol",[t("li",[e._v("When threads are finished, instances can be GCed as soon as possible.")]),e._v(" "),t("li",[e._v("The number of elements of ThreadLocalMap will decrease, then the probability of hash coflict of Map will decrease.")])]),e._v(" "),t("h5",{attrs:{id:"get"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#get"}},[e._v("#")]),e._v(" Get")]),e._v(" "),t("p",[e._v("Here is the source code:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("public T get() {\n    Thread t = Thread.currentThread();//Get current thread instance first\n    ThreadLocalMap map = getMap(t);//Get ThreadLocalMap of the current thread\n    if (map != null) {//If map is not null then get Entry by usingkey\n        ThreadLocalMap.Entry e = map.getEntry(this);\n        if (e != null)\n            return (T)e.value;\n     }\n     return setInitialValue();//If map is null then init it\n }\n")])])]),t("p",[e._v("About setInitialValue(), the default value is null and can be overrided.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("protected T initialValue() {\n    return null;\n}\n")])])])])}),[],!1,null,null,null);a.default=n.exports}}]);
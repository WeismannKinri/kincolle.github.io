(window.webpackJsonp=window.webpackJsonp||[]).push([[104],{721:function(e,t,n){"use strict";n.r(t);var o=n(0),r=Object(o.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h2",{attrs:{id:"introduction"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#introduction"}},[e._v("#")]),e._v(" Introduction")]),e._v(" "),n("p",[e._v("When mybatis do operation, it will use implementaion of SqlSession interface.")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v('SqlSession session = sqlMapper.openSession(TransactionIsolationLevel.SERIALIZABLE);\ntry {\n  List<Author> authors = session.selectList("org.apache.ibatis.domain.blog.mappers.AuthorMapper.selectAllAuthors");\n  assertEquals(2, authors.size());\n} finally {\n  session.close();\n}\n')])])]),n("p",[e._v("I'd like introduce selectList method of DefaultSqlSession class.")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v('public <E> List<E> selectList(String statement, Object parameter, RowBounds rowBounds) {\n  try {\n    MappedStatement ms = configuration.getMappedStatement(statement);\n    return executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);\n  } catch (Exception e) {\n    throw ExceptionFactory.wrapException("Error querying database.  Cause: " + e, e);\n  } finally {\n    ErrorContext.instance().reset();\n  }\n}\n')])])]),n("p",[e._v("We can get MappedStatement object from configuration and invoke query of Executor class to get the result we want. I have decribed that select node or update node is stored in MappedStatement. Which means, statement determines which one gonna execute select node.")]),e._v(" "),n("p",[e._v("The executor of DefaultSqlSession is setted in contruction method. So we need to checkout when the DefaultSqlSession class is being inited. The code is:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("public Executor newExecutor(Transaction transaction, ExecutorType executorType) {\n     executorType = executorType == null ? defaultExecutorType : executorType;\n     executorType = executorType == null ? ExecutorType.SIMPLE : executorType;\n     Executor executor;\n     if (ExecutorType.BATCH == executorType) {\n       executor = new BatchExecutor(this, transaction);\n     } else if (ExecutorType.REUSE == executorType) {\n       executor = new ReuseExecutor(this, transaction);\n     } else {\n       executor = new SimpleExecutor(this, transaction);\n     }\n     if (cacheEnabled) {\n       executor = new CachingExecutor(executor);\n     }\n     executor = (Executor) interceptorChain.pluginAll(executor);\n     return executor;\n}\n")])])]),n("p",[e._v("As we can see there 3 types of Executor:")]),e._v(" "),n("ul",[n("li",[e._v("ExecutorType.SIMPLE: Do not do special operation and every sql won't have a pretreatment SQL")]),e._v(" "),n("li",[e._v("ExecutorType.REUSE: It will reuse pretreatment SQL")]),e._v(" "),n("li",[e._v("ExecutorType.BATCH: Do things in batch")])]),e._v(" "),n("p",[e._v("Configuration Class:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("protected ExecutorType defaultExecutorType = ExecutorType.SIMPLE;\n")])])]),n("p",[e._v("So we know if we don't set the type of Executor class, the default will be SimpleExecutor class.")]),e._v(" "),n("p",[e._v("Also, we know in the selectList method of DefaultSqlSession class we will invoke query method of Executor finally.")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("return executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);\n")])])]),n("p",[e._v("BaseExecutor classï¼š")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("  public <E> List<E> query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler) throws SQLException {\n    BoundSql boundSql = ms.getBoundSql(parameter);\n    CacheKey key = createCacheKey(ms, parameter, rowBounds, boundSql);\n    return query(ms, parameter, rowBounds, resultHandler, key, boundSql);\n  }\n")])])]),n("p",[e._v("Like SimpleExecutor it does not extend Executor class but through BaseExecutor. So when invoke query method, it invokes query of BaseExecutor indeed.")]),e._v(" "),n("p",[e._v("SimpleExecutor class:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("public <E> List<E> doQuery(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) throws SQLException {\n     Statement stmt = null;\n     try {\n       Configuration configuration = ms.getConfiguration();\n       StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);\n       stmt = prepareStatement(handler, ms.getStatementLog());\n       return handler.<E>query(stmt, resultHandler) ; \n     } finally {\n       closeStatement(stmt);\n     }\n   }\n")])])])])}),[],!1,null,null,null);t.default=r.exports}}]);
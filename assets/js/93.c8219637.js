(window.webpackJsonp=window.webpackJsonp||[]).push([[93],{713:function(e,a,n){"use strict";n.r(a);var t=n(0),r=Object(t.a)({},(function(){var e=this,a=e.$createElement,n=e._self._c||a;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h2",{attrs:{id:"multi-datasource"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#multi-datasource"}},[e._v("#")]),e._v(" Multi DataSource")]),e._v(" "),n("p",[e._v("In real project, a service may use more than one data source. Here I will introduce how to change data source aotomatically by using Spring.")]),e._v(" "),n("h2",{attrs:{id:"_1-spring-config"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-spring-config"}},[e._v("#")]),e._v(" (1) Spring Config")]),e._v(" "),n("p",[e._v("Here are Spring config")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v('<context:component-scan base-package="kincolle.service,kincolle.aop" />\n<context:component-scan base-package="kincolle.aop" />\n\x3c!-- properties file --\x3e\n<context:property-placeholder location="classpath:config/db.properties" />\n\n\x3c!-- Data Source Config --\x3e\n<bean name="dataSource" class="com.alibaba.druid.pool.DruidDataSource" init-method="init" destroy-method="close">\n    <property name="url" value="${jdbc_url}" />\n    <property name="username" value="${jdbc_username}" />\n    <property name="password" value="${jdbc_password}" />\n    <property name="initialSize" value="0" />\n    <property name="maxActive" value="20" />\n    <property name="maxIdle" value="20" />\n    <property name="minIdle" value="0" />\n    <property name="maxWait" value="60000" />\n</bean>\n\n<bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean">\n  <property name="dataSource" ref="dataSource" />\n  <property name="configLocation" value="classpath:config/mybatis-config.xml" />\n  <property name="mapperLocations" value="classpath*:config/mappers/**/*.xml" />\n</bean>\n\n\x3c!-- Transaction manager for a single JDBC DataSource --\x3e\n<bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">\n    <property name="dataSource" ref="dataSource" />\n</bean>\n\n\x3c!-- Define transaction by using annotation --\x3e\n<tx:annotation-driven transaction-manager="transactionManager" /> \n\n<bean class="org.mybatis.spring.mapper.MapperScannerConfigurer">\n  <property name="basePackage" value="kincolle.mapper" />\n  <property name="sqlSessionFactoryBeanName" value="sqlSessionFactory"/>\n</bean>\n\n\x3c!-- Enables the use of the @AspectJ style of Spring AOP --\x3e\n<aop:aspectj-autoproxy/>\n\n\x3c!-- ===============The second data source config=============== --\x3e\n<bean name="dataSource_2" class="com.alibaba.druid.pool.DruidDataSource" init-method="init" destroy-method="close">\n    <property name="url" value="${jdbc_url_2}" />\n    <property name="username" value="${jdbc_username_2}" />\n    <property name="password" value="${jdbc_password_2}" />\n    <property name="initialSize" value="0" />\n    <property name="maxActive" value="20" />\n    <property name="maxIdle" value="20" />\n    <property name="minIdle" value="0" />\n    <property name="maxWait" value="60000" />\n</bean>\n\n<bean id="sqlSessionFactory_slave" class="org.mybatis.spring.SqlSessionFactoryBean">\n  <property name="dataSource" ref="dataSource_2" />\n  <property name="configLocation" value="classpath:config/mybatis-config-2.xml" />\n  <property name="mapperLocations" value="classpath*:config/mappers2/**/*.xml" />\n</bean>\n\n\x3c!-- Transaction manager for a single JDBC DataSource --\x3e\n<bean id="transactionManager_2" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">\n    <property name="dataSource" ref="dataSource_2" />\n</bean>\n\n\x3c!-- Define transaction by using annotation --\x3e\n<tx:annotation-driven transaction-manager="transactionManager_2" /> \n\n<bean class="org.mybatis.spring.mapper.MapperScannerConfigurer">\n  <property name="basePackage" value="kincolle.mapper2" />\n  <property name="sqlSessionFactoryBeanName" value="sqlSessionFactory_2"/>\n</bean>\n')])])]),n("p",[e._v("Like the code shows, we config 2 data sources and 2 transactionManagers.")]),e._v(" "),n("h2",{attrs:{id:"_2-using-abstractroutingdatasource-and-aop"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-using-abstractroutingdatasource-and-aop"}},[e._v("#")]),e._v(" (2) Using AbstractRoutingDataSource and AOP")]),e._v(" "),n("p",[e._v("(1)")]),e._v(" "),n("p",[e._v("First of all, we define a enum to mean different data source.")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("/**\n * Datasource:master/slave\n */\npublic enum DataSources {\n    MASTER, SLAVE\n}\n")])])]),n("p",[e._v("(2)")]),e._v(" "),n("p",[e._v("Using thread local to store data source key in every thread:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("public class DataSourceTypeManager {\n    private static final ThreadLocal<DataSources> dataSourceTypes = new ThreadLocal<DataSources>(){\n        @Override\n        protected DataSources initialValue(){\n            return DataSources.MASTER;\n        }\n    };\n    \n    public static DataSources get(){\n        return dataSourceTypes.get();\n    }\n    \n    public static void set(DataSources dataSourceType){\n        dataSourceTypes.set(dataSourceType);\n    }\n    \n    public static void reset(){\n        dataSourceTypes.set(DataSources.MASTER0);\n    }\n}\n")])])]),n("p",[e._v("(3)")]),e._v(" "),n("p",[e._v("Define ThreadLocalRountingDataSource and extends AbstractRoutingDataSource:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("public class ThreadLocalRountingDataSource extends AbstractRoutingDataSource {\n    @Override\n    protected Object determineCurrentLookupKey() {\n        return DataSourceTypeManager.get();\n    }\n}\n")])])]),n("p",[e._v("(4)")]),e._v(" "),n("p",[e._v("Input master and slave data source into ThreadLocalRountingDataSource in config file")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v('\t<context:component-scan base-package="kincolle.service,kincolle.aop" />\n    <context:component-scan base-package="kincolle.aop" />\n    \x3c!-- properties file --\x3e\n    <context:property-placeholder location="classpath:config/db.properties" />    \n    \x3c!-- Data Source Master --\x3e\n    <bean name="dataSourceMaster" class="com.alibaba.druid.pool.DruidDataSource" init-method="init" destroy-method="close">\n        <property name="url" value="${jdbc_url}" />\n        <property name="username" value="${jdbc_username}" />\n        <property name="password" value="${jdbc_password}" />\n        <property name="initialSize" value="0" />=\n        <property name="maxActive" value="20" />\n        <property name="maxIdle" value="20" />\n        <property name="minIdle" value="0" />\n        <property name="maxWait" value="60000" />\n    </bean>    \n    \x3c!-- Data Source Slave --\x3e\n    <bean name="dataSourceSlave" class="com.alibaba.druid.pool.DruidDataSource" init-method="init" destroy-method="close">\n        <property name="url" value="${jdbc_url_slave}" />\n        <property name="username" value="${jdbc_username_slave}" />\n        <property name="password" value="${jdbc_password_slave}" />\n        <property name="initialSize" value="0" />\n        <property name="maxActive" value="20" />\n        <property name="maxIdle" value="20" />\n        <property name="minIdle" value="0" />\n        <property name="maxWait" value="60000" />\n    </bean>    \n    <bean id="dataSource" class="kincolle.util.ThreadLocalRountingDataSource">\n        <property name="defaultTargetDataSource" ref="dataSourceMaster" />\n        <property name="targetDataSources">\n            <map key-type="kincolle.enums.DataSources">\n                <entry key="MASTER" value-ref="dataSourceMaster"/>\n                <entry key="SLAVE" value-ref="dataSourceSlave"/>\n            </map>\n        </property>\n    </bean>    \n    <bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean">\n      <property name="dataSource" ref="dataSource" />\n      <property name="configLocation" value="classpath:config/mybatis-config.xml" />\n      <property name="mapperLocations" value="classpath*:config/mappers/**/*.xml" />\n    </bean>    \n    \x3c!-- Transaction manager for a single JDBC DataSource --\x3e\n    <bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">\n        <property name="dataSource" ref="dataSource" />\n    </bean>    \n    \x3c!-- Define transaction by using annotation --\x3e\n    <tx:annotation-driven transaction-manager="transactionManager" /> \n    <bean class="org.mybatis.spring.mapper.MapperScannerConfigurer">\n      <property name="basePackage" value="kincolle.mapper" />\n      \x3c!-- <property name="sqlSessionFactoryBeanName" value="sqlSessionFactory"/> --\x3e\n    </bean>\n')])])]),n("p",[e._v("(5)")]),e._v(" "),n("p",[e._v("Using AOP to set Datasource key.")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v('@Aspect    // for aop\n@Component // for auto scan\n@Order(0)  // execute before @Transactional\npublic class DataSourceInterceptor {    \n    @Pointcut("execution(public * kincolle.service..*.getUser(..))")\n    public void dataSourceSlave(){};\n    \n    @Before("dataSourceSlave()")\n    public void before(JoinPoint jp) {\n        DataSourceTypeManager.set(DataSources.SLAVE);\n    }\n    // ... ...\n}\n')])])]),n("p",[e._v("(6)")]),e._v(" "),n("p",[e._v("AbstractRoutingDataSource")]),e._v(" "),n("p",[e._v('ThreadLocalRountingDataSource extends AbstractRoutingDataSource and implements abstract method "protected abstract Object determineCurrentLookupKey()" to route different data source. We analyze it from its source code:')]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("public abstract class AbstractRoutingDataSource extends AbstractDataSource implements InitializingBean\n")])])]),n("p",[e._v('AbstractRoutingDataSource implements InitializingBean, then when init bean in Spring, it will call "void afterPropertiesSet() throws Exception;" of InitializingBean. Here let\'s see how it works:')]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("@Override\npublic void afterPropertiesSet() {\n    if (this.targetDataSources == null) {\n        throw new IllegalArgumentException(\"Property 'targetDataSources' is required\");\n    }\n    this.resolvedDataSources = new HashMap<Object, DataSource>(this.targetDataSources.size());\n    for (Map.Entry<Object, Object> entry : this.targetDataSources.entrySet()) {\n        Object lookupKey = resolveSpecifiedLookupKey(entry.getKey());\n        DataSource dataSource = resolveSpecifiedDataSource(entry.getValue());\n        this.resolvedDataSources.put(lookupKey, dataSource);\n    }\n    if (this.defaultTargetDataSource != null) {\n        this.resolvedDefaultDataSource = resolveSpecifiedDataSource(this.defaultTargetDataSource);\n    }\n}\n")])])]),n("p",[e._v('targetDataSources is the dataSourceMaster and the dataSourceSlave we set in XML config file. The afterPropertiesSet mehtod is used for setting dataSourceMaster and  dataSourceSlave to build a HashMap——resolvedDataSources. Then we can get datasource from the map by using key. Let\'s see the "Connection getConnection() throws SQLException; " in AbstractDataSource.')]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("@Override\npublic Connection getConnection() throws SQLException {\n    return determineTargetDataSource().getConnection();\n}\n")])])]),n("p",[e._v("and about determineTargetDataSource()")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v('protected DataSource determineTargetDataSource() {\n    Assert.notNull(this.resolvedDataSources, "DataSource router not initialized");\n    Object lookupKey = determineCurrentLookupKey();\n    DataSource dataSource = this.resolvedDataSources.get(lookupKey);\n    if (dataSource == null && (this.lenientFallback || lookupKey == null)) {\n        dataSource = this.resolvedDefaultDataSource;\n    }\n    if (dataSource == null) {\n        throw new IllegalStateException("Cannot determine target DataSource for lookup key [" + lookupKey + "]");\n    }\n    return dataSource;\n}\n')])])]),n("p",[e._v('We implements "Object lookupKey = determineCurrentLookupKey(); " and save key in ThreadLocal. After get key we get datasource from map which is in resolvedDataSources by using key. And\nthe key in ThreadLocal is set by using AOP.')])])}),[],!1,null,null,null);a.default=r.exports}}]);
(window.webpackJsonp=window.webpackJsonp||[]).push([[92],{798:function(e,t,n){"use strict";n.r(t);var a=n(5),r=Object(a.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h2",{attrs:{id:"put-and-get-of-hashmap"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#put-and-get-of-hashmap"}},[e._v("#")]),e._v(" Put and Get of HashMap")]),e._v(" "),n("p",[e._v("I have introduced put and get of HashMap at "),n("a",{attrs:{href:"https://kincolle.github.io/2018/03/06/Collection-HashMapAndHashSet/",target:"_blank",rel:"noopener noreferrer"}},[e._v("here"),n("OutboundLink")],1),e._v(". To introduce the reason for conflict of HashMap, I'd like to introduce put and get of HashMap again."),n("br"),e._v("\nHere, let's see how put work:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("public V put(K key, V value) {\n    if (key == null)\n        return putForNullKey(value);\n    // get hash value for key\n\tint hash = hash(key);\n    // get the index of array\n    int i = indexFor(hash, table.length);\n    // if at i position is not null, the using next to iterate the next element\n    for (Entry<K,V> e = table[i]; e != null; e = e.next) {\n        Object k;\n        if (e.hash == hash && ((k = e.key) == key || key.equals(k))) {\n            V oldValue = e.value;\n            e.value = value;\n            e.recordAccess(this);\n            return oldValue;\n        }\n    }\n\n    modCount++;\n    addEntry(hash, key, value, i);\n    return null;\n}\n")])])]),n("p",[e._v("Here use some functions:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("static int hash(int h) {\n    h ^= (h >>> 20) ^ (h >>> 12);\n    return h ^ (h >>> 7) ^ (h >>> 4);\n}\n \nstatic int indexFor(int h, int length) {\n    return h & (length-1);\n}\n")])])]),n("p",[e._v("When we finished put(), here is how we use get()")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("public V get(Object key) {\n    if (key == null)\n        return getForNullKey();\n    int hash = hash(key.hashCode());\n    /**\n      * first find the position in the array\n      * then check whether the hashcode of key equals and the key value equals\n      */\n    for (Entry<K,V> e = table[indexFor(hash, table.length)];e != null;e = e.next) {\n        Object k;\n        if (e.hash == hash && ((k = e.key) == key || key.equals(k)))\n            return e.value;\n    }\n    return null;\n}\n")])])]),n("p",[e._v("Check the constructure of the Entry:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("static class Entry<K,V> implements Map.Entry<K,V> {\n   final K key;//key of Key-value\n   V value;// stored value\n   Entry<K,V> next;// point to next entry\n   final int hash;// hashcode\n}\n")])])]),n("h2",{attrs:{id:"rehash"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#rehash"}},[e._v("#")]),e._v(" Rehash")]),e._v(" "),n("p",[e._v("I have introduced rehash of HashMap in "),n("a",{attrs:{href:"https://kincolle.github.io/2018/03/06/Collection-HashMapAndHashSet/",target:"_blank",rel:"noopener noreferrer"}},[e._v("here"),n("OutboundLink")],1),e._v(". I plan to introduce it in detail."),n("br"),e._v("\nAt the best situation, the runtime of both get and put is O(1). But in fact, there has conflict will more than one entry at the same index of array. So the linked list is used for solving this problem, but the runtime will be O(N). So, to let the hash be meaningful, we must keep a balance of size of array and linkedlist. That is why we need to rehash."),n("br"),e._v("\nHere let's see the addEntry():")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("void addEntry(int hash, K key, V value, int bucketIndex) {\n\tEntry<K,V> e = table[bucketIndex];\n    table[bucketIndex] = new Entry<K,V>(hash, key, value, e);\n    if (size++ >= threshold)\n\t\tresize(2 * table.length);\n}\n")])])]),n("p",[e._v("Here is the resize that change the size of table and make it double:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("void resize(int newCapacity) {\n   Entry[] oldTable = table;\n   int oldCapacity = oldTable.length;\n   if (oldCapacity == MAXIMUM_CAPACITY) {\n       threshold = Integer.MAX_VALUE;\n       return;\n   }\n\n   Entry[] newTable = new Entry[newCapacity];\n   //initial a new table that size is twice than old table\n   transfer(newTable);\n   table = newTable;\n   threshold = (int)(newCapacity * loadFactor);\n}\n")])])]),n("p",[e._v("The point is transfer(newTable), this operation wiill move the current elements of Entry[] table into the new table. At multi-threads situation, problems may happen which is Infinite Loop.")]),e._v(" "),n("h2",{attrs:{id:"infinite-loop-problem"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#infinite-loop-problem"}},[e._v("#")]),e._v(" Infinite Loop Problem")]),e._v(" "),n("h5",{attrs:{id:"_1-persuming-we-have-thread-t1-and-thread-t2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-persuming-we-have-thread-t1-and-thread-t2"}},[e._v("#")]),e._v(" 1. Persuming we have thread T1 and thread T2.")]),e._v(" "),n("p",[e._v("Here let's see the transfer:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("oid transfer(Entry[] newTable) {\n    Entry[] src = table;\n    int newCapacity = newTable.length;\n    for (int j = 0; j < src.length; j++) {\n        Entry<K,V> e = src[j];\n        if (e != null) {\n            src[j] = null;\n            do {\n    // persuming the first thread T1 is hung out for some reason at here  \n                Entry<K,V> next = e.next;\n                int i = indexFor(e.hash, newCapacity);\n                e.next = newTable[i];\n                newTable[i] = e;\n                e = next;\n            } while (e != null);\n        }\n    }\n}\n")])])]),n("p",[e._v("Here let's see how the problem happen:\nPersuming thread T2 finished and will be like the following:")]),e._v(" "),n("p",[n("img",{attrs:{src:"/Concurrency-Java-ReasonForConflictOfHashMap/HashMap02.jpg",alt:""}})]),e._v(" "),n("p",[e._v("Here,because e of T1 points to key(3) and its next points to key(7), and after T2 rehashed, the order are reversed.")]),e._v(" "),n("h5",{attrs:{id:"_2-t1-do-work"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-t1-do-work"}},[e._v("#")]),e._v(" 2. T1 do work")]),e._v(" "),n("ul",[n("li",[e._v('T1 do "newTalbe[i] = e;"')]),e._v(" "),n("li",[e._v('then do "e = next", that leads e point to key(7)')]),e._v(" "),n("li",[e._v('At the next loop, "next = e.next" let next point to key(3)')])]),e._v(" "),n("p",[n("img",{attrs:{src:"/Concurrency-Java-ReasonForConflictOfHashMap/HashMap03.jpg",alt:""}})]),e._v(" "),n("h5",{attrs:{id:"_3-continue"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-continue"}},[e._v("#")]),e._v(" 3. Continue")]),e._v(" "),n("p",[e._v("T1 continue to work. Put key(7)down and set it at the first place of newTable[i],  then move e and next to the next one.")]),e._v(" "),n("p",[n("img",{attrs:{src:"/Concurrency-Java-ReasonForConflictOfHashMap/HashMap04.jpg",alt:""}})]),e._v(" "),n("h5",{attrs:{id:"_4-infinite-loop"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_4-infinite-loop"}},[e._v("#")]),e._v(" 4. Infinite Loop")]),e._v(" "),n("p",[e._v("The e.next = newTable[i] let key(3).next point to key(7). But, at this time, key(7).next has already pointed to key(3), so the infinite loop happens.")]),e._v(" "),n("p",[n("img",{attrs:{src:"/Concurrency-Java-ReasonForConflictOfHashMap/HashMap05.jpg",alt:""}})]),e._v(" "),n("p",[e._v("Then, when T1 invokes HashTable.get(11), inifinite loop happens.")])])}),[],!1,null,null,null);t.default=r.exports}}]);
(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{634:function(e,t,n){e.exports=n.p+"assets/img/1.69fdadf2.png"},635:function(e,t,n){e.exports=n.p+"assets/img/2.f6b3b8d9.png"},636:function(e,t,n){e.exports=n.p+"assets/img/3.04b2cba1.png"},637:function(e,t,n){e.exports=n.p+"assets/img/4.4a0f35ee.png"},785:function(e,t,n){"use strict";n.r(t);var a=n(5),r=Object(a.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"linkedhashmap-and-linkedhashset"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#linkedhashmap-and-linkedhashset"}},[e._v("#")]),e._v(" LinkedHashMap and LinkedHashSet")]),e._v(" "),a("h2",{attrs:{id:"introduction-of-linkedhashmap"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#introduction-of-linkedhashmap"}},[e._v("#")]),e._v(" Introduction of LinkedHashMap")]),e._v(" "),a("p",[e._v("HashMap is unordered, which means the order of get() may not the same as the order of put(). Here is a example:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v('public static void main(String[] args) {\n    Map<String, String> map = new HashMap<String, String>();\n    map.put("apple", "リンゴ");\n    map.put("watermelon", "スイカ");\n    map.put("banana", "バナナ");\n    map.put("peach", "モモ");\n\n    Iterator iter = map.entrySet().iterator();\n    while (iter.hasNext()) {\n        Map.Entry entry = (Map.Entry) iter.next();\n        System.out.println(entry.getKey() + "=" + entry.getValue());\n    }\n}\n')])])]),a("p",[e._v("And the outcome is:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("banana=バナナ\napple=リンゴ\npeach=モモ\nwatermelon=スイカ\n")])])]),a("p",[e._v('If you implement map by using LinkedHashMap which is "Map<String, String> map = new LinkedHashMap<String, String>();", then the outcome will be:')]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("apple=リンゴ\nwatermelon=スイカ\nbanana=バナナ\npeach=モモ\n")])])]),a("p",[e._v("You can see that the order of outcome is the order of put(). How nice! In fact, you can get a order of get(). I will explain it latter. Now, I will show you a picture of architecture of LinkedHashMap:")]),e._v(" "),a("p",[a("img",{attrs:{src:n(634),alt:""}})]),e._v(" "),a("p",[e._v("LinkedHashMap is subclass of HashMap, the only different point is that LinkedHashMap implements a linkedlist on every entry of HashMap, that is for ordering. Here a picture about Entry:")]),e._v(" "),a("p",[a("img",{attrs:{src:n(635),alt:""}})]),e._v(" "),a("p",[e._v("So, LinkedHashMap has some charaters like HashMap like:")]),e._v(" "),a("ul",[a("li",[e._v("key can be null and can not be duplicated")]),e._v(" "),a("li",[e._v("value can be null and can be duplicated")]),e._v(" "),a("li",[e._v("it is not thread safe")])]),e._v(" "),a("h2",{attrs:{id:"implementation-of-linkedhashmap"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#implementation-of-linkedhashmap"}},[e._v("#")]),e._v(" Implementation of LinkedHashMap")]),e._v(" "),a("h5",{attrs:{id:"member-variables"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#member-variables"}},[e._v("#")]),e._v(" Member Variables")]),e._v(" "),a("p",[e._v("LinkedHashMap use hash algorithm which is the same to HashMap, but it redifined Entry as I have showed in the picture. Here is the source code of Entry:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("/**\n* The iteration ordering method for this linked hash map: <tt>true</tt>\n* for access-order, <tt>false</tt> for insertion-order.\n* if true, then order as get,if flase, then order as put\n*/\nprivate final boolean accessOrder;\n/**\n* head of double list\n */\nprivate transient Entry<K,V> header;\n\n/**\n* element of Entry of LinkedHashMap\n* it extends Hashmap and add before and after\n */\nprivate static class Entry<K,V> extends HashMap.Entry<K,V> {\n    Entry<K,V> before, after;\n    ……\n}\n")])])]),a("h5",{attrs:{id:"initialization"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#initialization"}},[e._v("#")]),e._v(" Initialization")]),e._v(" "),a("p",[e._v("From the source code, we can know that in the contructor of LinkedHashMap, it uses the super() which is the constructor of HashMap to construct a table array, and adds a variables named accessOrder which its default value is false. If value of accessOrder is true it means the order of element is get(), if value of accessOrder is flase it means the order of element is put(). Here is the source code:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("public LinkedHashMap(int initialCapacity, float loadFactor,boolean accessOrder) {\n\tsuper(initialCapacity, loadFactor);\n\tthis.accessOrder = accessOrder;\n}\n")])])]),a("p",[e._v("As we know, Entry of LinkedHashMap entends from Entry of HashMap and has function of double linkedlist. In the constructor of HashMap, it will invokes init() finally. This function is not meanningful if implemented in HashMap. So, in LinkedHashMap, init() is overrided. Here is the source code:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("/**\n* Called by superclass constructors and pseudoconstructors (clone,\n* readObject) before any entries are inserted into the map.  Initializes\n* the chain.\n*/\n@Override\nvoid init() {\n  header = new Entry<>(-1, null, null, null);\n  header.before = header.after = header;\n}\n")])])]),a("h5",{attrs:{id:"storage"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#storage"}},[e._v("#")]),e._v(" Storage")]),e._v(" "),a("p",[e._v('LinkedHashMap didn\'t override put() of HashMap, but overrides subfunctions of put() that are "void recordAccess(HashMap m)", "void addEntry(int hash, K key, V value, int bucketIndex)" and "void createEntry(int hash, K key, V value, int bucketIndex)". They provide implementation of double linkedlist. Here is the source code of HashMap：')]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("\tpublic V put(K key, V value) {\n        if (key == null)\n            return putForNullKey(value);\n        int hash = hash(key);\n        int i = indexFor(hash, table.length);\n        for (Entry<K,V> e = table[i]; e != null; e = e.next) {\n            Object k;\n            if (e.hash == hash && ((k = e.key) == key || key.equals(k))) {\n                V oldValue = e.value;\n                e.value = value;\n                e.recordAccess(this);\n                return oldValue;\n            }\n        }\n\n        modCount++;\n        addEntry(hash, key, value, i);\n        return null;\n\t}\n")])])]),a("p",[e._v("And the overrided function is:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("void recordAccess(HashMap<K,V> m) {\n    LinkedHashMap<K,V> lm = (LinkedHashMap<K,V>)m;\n    if (lm.accessOrder) {\n        lm.modCount++;\n        remove();\n        addBefore(lm.header);\n        }\n}\n\nvoid addEntry(int hash, K key, V value, int bucketIndex) {\n    // when invoke create(), new element will be put into double linked list\n    createEntry(hash, key, value, bucketIndex);\n\n    // strategy of deleting the most useless elements recently\n    Entry<K,V> eldest = header.after;\n    if (removeEldestEntry(eldest)) {\n        removeEntryForKey(eldest.key);\n    } else {\n        if (size >= threshold)\n            resize(2 * table.length);\n    }\n}\n\nvoid createEntry(int hash, K key, V value, int bucketIndex) {\n    HashMap.Entry<K,V> old = table[bucketIndex];\n    Entry<K,V> e = new Entry<K,V>(hash, key, value, old);\n    table[bucketIndex] = e;\n\t// when invoke addBrefore(), it will be ut into hash and double linked list\n    e.addBefore(header);\n    size++;\n}\n\nprivate void addBefore(Entry<K,V> existingEntry) {\n    after  = existingEntry;\n    before = existingEntry.before;\n    before.after = this;\n    after.before = this;\n}\n")])])]),a("p",[e._v("Here this picture will show you the architecture when addEntry():\n"),a("img",{attrs:{src:n(636),alt:""}})]),e._v(" "),a("h5",{attrs:{id:"remove"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#remove"}},[e._v("#")]),e._v(" Remove")]),e._v(" "),a("p",[e._v('"remove(Object key)" is used for delete entry of one key. The logic of This function is implemented in "removeEntryForKey(Object key)". "removeEntryForKey()" will find entry by using on key and delete the entry, it is like get().'),a("br"),e._v("\nThere 2 means of delete:")]),e._v(" "),a("ul",[a("li",[e._v("For table, it needs to delete this entry from bucket")]),e._v(" "),a("li",[e._v("For header, it needs to delete this entry from double linked list")])]),e._v(" "),a("p",[a("img",{attrs:{src:n(637),alt:""}})]),e._v(" "),a("p",[e._v("The source code of removeEntryForKey() is here:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("// LinkedHashMap.removeEntryForKey()，delete one entry of one key\nfinal Entry<K,V> removeEntryForKey(Object key) {\n    ......\n    int hash = (key == null) ? 0 : hash(key);\n    int i = indexFor(hash, table.length);// hash&(table.length-1)\n    Entry<K,V> prev = table[i];// get table\n    Entry<K,V> e = prev;\n    while (e != null) {// iterate the table\n        Entry<K,V> next = e.next;\n        Object k;\n        if (e.hash == hash &&\n            ((k = e.key) == key || (key != null && key.equals(k)))) {// find the entry needs to be deleted\n            modCount++; size--;\n            // 1. delete e from the bucket\n            if (prev == e) table[i] = next;\n            else prev.next = next;\n            // 2. delete e from the double linked list\n            e.before.after = e.after;\n            e.after.before = e.before;\n            return e;\n        }\n        prev = e; e = next;\n    }\n    return e;\n}\n")])])]),a("h5",{attrs:{id:"get"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#get"}},[e._v("#")]),e._v(" Get")]),e._v(" "),a("p",[e._v("LinkedHashMap overrides get() of HashMap, when get element after invoke getEntry(), then judge the accessOrder. When it is true, it will record order of get and will set the element to the head of double linked list and delete the element at the old position after invoke get(). Due to add() and delete() of linked list is O(1), so there is no problem of performance. Here is the source code:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("public V get(Object key) {\n    // invoke getEntry() of super class to get element\n    Entry<K,V> e = (Entry<K,V>)getEntry(key);\n    if (e == null)\n        return null;\n    // record order of get()\n    e.recordAccess(this);\n    return e.value;\n}\n\nvoid recordAccess(HashMap<K,V> m) {\n    LinkedHashMap<K,V> lm = (LinkedHashMap<K,V>)m;\n    // if order of access of LinkedHashMap has been defined, the delete element of this position and add this element to the head of linked list\n    if (lm.accessOrder) {\n        lm.modCount++;\n        remove();\n        addBefore(lm.header);\n    }\n}\n\n/**\n* Removes this entry from the linked list.\n*/\nprivate void remove() {\n    before.after = after;\n    after.before = before;\n}\n\n/**clear linked list，set header as initial status*/\npublic void clear() {\n super.clear();\n header.before = header.after = header;\n}\n")])])]),a("h5",{attrs:{id:"order-pattern"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#order-pattern"}},[e._v("#")]),e._v(" Order Pattern")]),e._v(" "),a("p",[e._v("LinkedHashMap defines accessOrder which is a boolean variable. It is true for get order and flase for input order. The default value is flase."),a("br"),e._v('\nThere constructors will define default order pattern. If you want to construct a LinkedHashMap and want to hava a order from recently access less to recently access more to store data, then use the following contructor: "LinkedHashMap：public LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder)".')])])}),[],!1,null,null,null);t.default=r.exports}}]);
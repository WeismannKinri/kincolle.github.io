(window.webpackJsonp=window.webpackJsonp||[]).push([[49],{539:function(e,t,a){e.exports=a.p+"assets/img/HashMapArrayLinkedList.738a451b.jpg"},681:function(e,t,a){"use strict";a.r(t);var n=a(0),i=Object(n.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"map"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#map"}},[e._v("#")]),e._v(" Map")]),e._v(" "),n("p",[e._v("Map uses key-value type. Keys of Map can not be duplicated and each key can lead to a value.")]),e._v(" "),n("h2",{attrs:{id:"hashmap"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#hashmap"}},[e._v("#")]),e._v(" HashMap")]),e._v(" "),n("h3",{attrs:{id:"_1-1-introduction-of-hashmap"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-introduction-of-hashmap"}},[e._v("#")]),e._v(" 1.1 Introduction of HashMap")]),e._v(" "),n("p",[e._v("HashMap is based on Hash Table and implements Map interface. HashMap allows null key and null value. But, it does not make sure order especially it can not make sure order never be changed."),n("br"),e._v("\nPersuming hash function puts elements equably into each bucket. If performance of iterator is important for you, do not set the initial capacity too high (or the load factor too low). You may do not understand why, I will explain it latter."),n("br"),e._v("\nBy the way, HashMap is not thread safe.")]),e._v(" "),n("h3",{attrs:{id:"_1-2-data-structure"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-data-structure"}},[e._v("#")]),e._v(" 1.2 Data Structure")]),e._v(" "),n("p",[e._v("In java language, there are two basic data structure: array and pointer and HashMap use both of them. In fact, HashMap is hash linked list sctucture which means is combined with array and linked list.\n"),n("img",{attrs:{src:a(539),alt:""}}),e._v("\nFrom the picture we can see that the basic structure is array and every element of the array is a linked list. So, when initiate a new HashMap, it will create a new array. "),n("br"),e._v("\nHere is the source code:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v('public HashMap(int initialCapacity, float loadFactor) {\n    if (initialCapacity < 0)\n        throw new IllegalArgumentException("Illegal initial capacity: " +\n                                           initialCapacity);\n    if (initialCapacity > MAXIMUM_CAPACITY)\n        initialCapacity = MAXIMUM_CAPACITY;\n    if (loadFactor <= 0 || Float.isNaN(loadFactor))\n        throw new IllegalArgumentException("Illegal load factor: " +\n                                           loadFactor);\n\n    // Find a power of 2 >= initialCapacity\n    int capacity = 1;\n    while (capacity < initialCapacity)\n        capacity <<= 1;\n\n    this.loadFactor = loadFactor;\n    threshold = (int)Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1);\n    table = new Entry[capacity];\n    useAltHashing = sun.misc.VM.isBooted() &&\n            (capacity >= Holder.ALTERNATIVE_HASHING_THRESHOLD);\n    init();\n}\n')])])]),n("p",[e._v('In the source code, there is a code like "table = new Entry[capacity];". That is the way how java create an array. That means in the construction function, create a Entry array with defined capacity. So, what is the structure of Entry? Let\'s see the source code:')]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("static class Entry<K,V> implements Map.Entry<K,V> {\n    final K key;\n    V value;\n    Entry<K,V> next;\n    final int hash;\n    ……\n}\n")])])]),n("p",[e._v("Entry is a static class which contains key-value. Also, it contains a pointer of Entry type named next. So we can get a conclusion that every Entry has a key value and it points to the next element.")]),e._v(" "),n("h3",{attrs:{id:"_1-3-storage"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-storage"}},[e._v("#")]),e._v(" 1.3 Storage")]),e._v(" "),n("p",[e._v("First of all, let's see the source code:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("/**\n * Associates the specified value with the specified key in this map.\n * If the map previously contained a mapping for the key, the old\n * value is replaced.\n *\n * @param key key with which the specified value is to be associated\n * @param value value to be associated with the specified key\n * @return the previous value associated with <tt>key</tt>, or\n *         <tt>null</tt> if there was no mapping for <tt>key</tt>.\n *         (A <tt>null</tt> return can also indicate that the map\n *         previously associated <tt>null</tt> with <tt>key</tt>.)\n */\npublic V put(K key, V value) {\n    //allow store null ket and null value, when the key is null, putForNullKey function will be invoked and input data into table[0]\n    if (key == null)\n        return putForNullKey(value);\n    // get hash value for key\n    int hash = hash(key);\n    //get index i by using hash value\n    int i = indexFor(hash, table.length);\n    //if at i position is not null, the using next to iterate the next element\n    for (Entry<K,V> e = table[i]; e != null; e = e.next) {\n        Object k;\n        if (e.hash == hash && ((k = e.key) == key || key.equals(k))) {\n            V oldValue = e.value;\n            e.value = value;\n            e.recordAccess(this);\n            return oldValue;\n        }\n    }\n\n    modCount++;\n    addEntry(hash, key, value, i);\n    return null;\n}\n")])])]),n("p",[e._v("From the comment we can know that: when we put an element, if the key exists, the new value will replace old one and return old one, if not it will return null."),n("br"),e._v("\nAlso, we can know from the source code that: when we put an element, it will compute hash value of key and get the position by using hash value. If this in position exists a value put the element in linkedlist type, new element will be put at head and the oldest element will be put at the tail. If this in position exists no value, the put the value at this position."),n("br"),e._v("\naddEntry(hash, key, value, i) will put key-value at i position of array table by using hash value. The source is :")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("/**\n * Adds a new entry with the specified key, value and hash code to\n * the specified bucket.  It is the responsibility of this\n * method to resize the table if appropriate.\n *\n * Subclass overrides this to alter the behavior of put method.\n */\nvoid addEntry(int hash, K key, V value, int bucketIndex) {\n    if ((size >= threshold) && (null != table[bucketIndex])) {\n        resize(2 * table.length);\n        hash = (null != key) ? hash(key) : 0;\n        bucketIndex = indexFor(hash, table.length);\n    }\n\n    createEntry(hash, key, value, bucketIndex);\n}\nvoid createEntry(int hash, K key, V value, int bucketIndex) {\n    // get the Entry at the bucketIndex position\n    Entry<K,V> e = table[bucketIndex];\n    // Put the new created Entry into bucketIndex position and ley the new Entry point to the old Entry\n    table[bucketIndex] = new Entry<>(hash, key, value, e);\n    size++;\n} \n")])])]),n("p",[e._v("When system want to store a key-value, it does not consider value of Entry, and just get the position by using key. We also can use the value to be a key can determine the position to store, and then store the value."),n("br"),e._v("\nhash(int h) can compute hash value according to the key. This function can avoid hash confliction.\nHere is the source code:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("final int hash(Object k) {\n    int h = 0;\n    if (useAltHashing) {\n        if (k instanceof String) {\n            return sun.misc.Hashing.stringHash32((String) k);\n        }\n        h = hashSeed;\n    }\n    // get hashcode of k\n    h ^= k.hashCode();\n    //do computing\n    h ^= (h >>> 20) ^ (h >>> 12);\n    return h ^ (h >>> 7) ^ (h >>> 4);\n}\n")])])]),n("p",[e._v("We can get position bt using hash code instead of iteration. That's is high efficiency. About hash code here is the source code:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("/**\n * Returns index for hash code h.\n */\nstatic int indexFor(int h, int length) {  \n    return h & (length-1);\n}\n\n// Find a power of 2 >= initialCapacity\nint capacity = 1;\nwhile (capacity < initialCapacity)  \n    capacity <<= 1;\n")])])]),n("h3",{attrs:{id:"_1-4-get"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-get"}},[e._v("#")]),e._v(" 1.4 Get")]),e._v(" "),n("p",[e._v("Here is source code about getting element:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("/**\n * Returns the value to which the specified key is mapped,\n * or {@code null} if this map contains no mapping for the key.\n *\n * <p>More formally, if this map contains a mapping from a key\n * {@code k} to a value {@code v} such that {@code (key==null ? k==null :\n * key.equals(k))}, then this method returns {@code v}; otherwise\n * it returns {@code null}.  (There can be at most one such mapping.)\n *\n * <p>A return value of {@code null} does not <i>necessarily</i>\n * indicate that the map contains no mapping for the key; it's also\n * possible that the map explicitly maps the key to {@code null}.\n * The {@link #containsKey containsKey} operation may be used to\n * distinguish these two cases.\n *\n * @see #put(Object, Object)\n */\npublic V get(Object key) {\n    if (key == null)\n        return getForNullKey();\n    Entry<K,V> entry = getEntry(key);\n\n    return null == entry ? null : entry.getValue();\n}\nfinal Entry<K,V> getEntry(Object key) {\n    int hash = (key == null) ? 0 : hash(key);\n    for (Entry<K,V> e = table[indexFor(hash, table.length)];\n         e != null;\n         e = e.next) {\n        Object k;\n        if (e.hash == hash &&\n            ((k = e.key) == key || (key != null && key.equals(k))))\n            return e;\n    }\n    return null;\n}\n")])])]),n("p",[e._v("As we already have knowledge of storage, it's easy to understand the getting. To get a element, firstly computing hashcode of a key and get a value of array then use key to get element we want.")]),e._v(" "),n("h3",{attrs:{id:"_1-5-summary-of-hashmap"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-5-summary-of-hashmap"}},[e._v("#")]),e._v(" 1.5 Summary Of HashMap")]),e._v(" "),n("p",[e._v("We can treat key-value as a Entry instance. The Entry[] willl store all key-value. When we want to store one, it will dicide its position at array by using hash code, and use equals() to determine the position at the linked list. When we want to get a Entry, we also  using hash code to find its position at array and use equals() to get the Entry we want.")]),e._v(" "),n("h3",{attrs:{id:"_1-6-resize-of-hashmap"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-6-resize-of-hashmap"}},[e._v("#")]),e._v(" 1.6 Resize of HashMap")]),e._v(" "),n("p",[e._v("When number of elements of one HashMap gets bigger, the ratio of getting confliction is getting higher because the length of array is setted. To increase the performance of the getting, we need to increase the size of array. After size of array has been increased, all the element of map will be relocated and that will do a lot of computing."),n("br"),e._v("\nSo, when will the system do resize? When number of element is over size(array)"),n("em",[e._v("loadFactor, it will do resize. The default loadFactor is 0.75 and the default size of array is 16. Then, when number of element is over 16")]),e._v("0.75=12, it will increase the size of array to 32. So, forecasting the element number will be helpful.")]),e._v(" "),n("h3",{attrs:{id:"_1-7-parameter-of-hashmap"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-7-parameter-of-hashmap"}},[e._v("#")]),e._v(" 1.7 Parameter of Hashmap")]),e._v(" "),n("p",[e._v("There are three kinds of construction:")]),e._v(" "),n("ul",[n("li",[e._v("HashMap()：build a HashMap with Capacity of 16 and loadFactor of 0.75")]),e._v(" "),n("li",[e._v("HashMap(int initialCapacity)：build a HashMap with Capacity of initialCapacity and loadFactor of 0.75")]),e._v(" "),n("li",[e._v("HashMap(int initialCapacity, float loadFactor)： build a HashMap with Capacity of initialCapacity and loadFactor of loadFactor")])]),e._v(" "),n("h3",{attrs:{id:"_1-8-fail-fast-strategy"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-8-fail-fast-strategy"}},[e._v("#")]),e._v(" 1.8 Fail-Fast Strategy")]),e._v(" "),n("p",[e._v("We know that HashMap is not thread safe. If some other threads change the map, ConcurrentModificationException will be thrown out. That is Fail-Fast strategy. "),n("br"),e._v("\nIt is implemented by using modCount. The modCount means the times of changing. Here is the source code:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("HashIterator() {\n    expectedModCount = modCount;\n    if (size > 0) { // advance to first entry\n    Entry[] t = table;\n    while (index < t.length && (next = t[index++]) == null)  \n        ;\n    }\n}\n")])])]),n("p",[e._v("When iterate, will judge if modCount equals expectedModCount.")]),e._v(" "),n("h1",{attrs:{id:"hashset"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#hashset"}},[e._v("#")]),e._v(" HashSet")]),e._v(" "),n("h2",{attrs:{id:"_1-introduction-of-hashset"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-introduction-of-hashset"}},[e._v("#")]),e._v(" 1 Introduction of HashSet")]),e._v(" "),n("p",[e._v("HashSet is implemented by using HashMap. So, if you know HashMao very well, you can understand HashSet quickly."),n("br"),e._v("\nHere let's see the construction of HashSet:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("private transient HashMap<E,Object> map;\n\n// Dummy value to associate with an Object in the backing Map\nprivate static final Object PRESENT = new Object();\n\n/**\n * Constructs a new, empty set; the backing <tt>HashMap</tt> instance has\n * default initial capacity (16) and load factor (0.75).\n */\npublic HashSet() {\n    map = new HashMap<>();\n}\n")])])]),n("p",[e._v("We can see that it is constructed by using HashMap.")]),e._v(" "),n("h2",{attrs:{id:"implementation-of-hashset"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#implementation-of-hashset"}},[e._v("#")]),e._v(" Implementation of HashSet")]),e._v(" "),n("p",[e._v("For HashSet, since it uses HashMap, the element is stored in HashMap．So most function of HashSet is the same to HashMap.")]),e._v(" "),n("h5",{attrs:{id:"construction"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#construction"}},[e._v("#")]),e._v(" construction")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v(" /**\n * defaulf constructor and will construct a empty HashSet\n *\n * In fact it will construct a empty HashMap with Capacity of 16 and loadFactor of 0.75\n */\npublic HashSet() {\n    map = new HashMap<E,Object>();\n}\n\n/**\n * Create a new HashSet with all elements of the collection\n *\n * it will construct a empty HashMap with Capacity of 16 and loadFactor of 0.75\n * @param element of c will be stored in this HashSet\n */\npublic HashSet(Collection<? extends E> c) {\n    map = new HashMap<E,Object>(Math.max((int) (c.size()/.75f) + 1, 16));\n    addAll(c);\n}\n\n/**\n * create a new empty HashSet with Capacity of initialCapacity and loadFactor of loadFactor\n *\n * @param initialCapacity \n * @param loadFactor \n */\npublic HashSet(int initialCapacity, float loadFactor) {\n    map = new HashMap<E,Object>(initialCapacity, loadFactor);\n}\n\n/**\n * build a new empty HashSet with Capacity of initialCapacity and loadFactor of 0.75\n *\n * @param initialCapacity \n */\npublic HashSet(int initialCapacity) {\n    map = new HashMap<E,Object>(initialCapacity);\n}\n")])])]),n("h5",{attrs:{id:"add"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#add"}},[e._v("#")]),e._v(" add")]),e._v(" "),n("p",[e._v("Here is the source code:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("/**\n\n * @param e the e will be put into the set\n * @return if there is no e in this set, then returen ture\n */\npublic boolean add(E e) {\n    return map.put(e, PRESENT)==null;\n}\n")])])]),n("p",[e._v("If the set is not containing e, then it will be put into the set. "),n("br"),e._v("\nIn HashMap, will put key-value, the key will never be duplicated. That's why the elements of set will never be duplicated.")])])}),[],!1,null,null,null);t.default=i.exports}}]);